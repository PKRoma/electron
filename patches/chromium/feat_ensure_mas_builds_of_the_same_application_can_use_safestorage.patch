From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samuel Attard <sattard@salesforce.com>
Date: Thu, 29 Sep 2022 16:58:47 -0700
Subject: feat: ensure mas builds of the same application can use safestorage

This change ensures that MAS builds of applications with an equivilant darwin build that share the same name do not fight over access to the same Safe Storage account.

Specifically this changes the account name for app "My App" from "My App" to "My App AppStore" if the app is using a MAS build of Electron.

We attempt to migrate the safe storage key from the old account, if that migration succeeds we delete the old key and move on.

Existing apps that aren't built for the app store should be unimpacted, there is one edge case where a user uses BOTH an AppStore and a darwin build of the same app only one will keep it's access to the safestorage key as during the migration we delete the old account.  This is an acceptable edge case as no one should be actively using two versions of the same app.

diff --git a/components/os_crypt/common/keychain_password_mac.mm b/components/os_crypt/common/keychain_password_mac.mm
index f19628cc0cdba39b232f55935e8eee9786b02a77..ab6ce9b1cf85029050a7497cd53813a03a46d408 100644
--- a/components/os_crypt/common/keychain_password_mac.mm
+++ b/components/os_crypt/common/keychain_password_mac.mm
@@ -27,6 +27,12 @@
 using KeychainNameContainerType = const base::NoDestructor<std::string>;
 #endif
 
+#if IS_MAS_BUILD()
+const char kAccountNameSuffix[] = " App Store Key";
+#else
+const char kAccountNameSuffix[] = " Key";
+#endif
+
 namespace {
 
 // These two strings ARE indeed user facing.  But they are used to access
@@ -96,18 +102,56 @@
                                   uma_result);
   };
 
+  const std::string account_name_suffix = kAccountNameSuffix;
+  const std::string suffixed_account_name = GetAccountName() + account_name_suffix;
   auto password =
+      keychain_->FindGenericPassword(GetServiceName(), suffixed_account_name);
+
+  if (password.has_value()) {
+    uma_result = FindGenericPasswordResult::kPasswordFound;
+    return std::string(base::as_string_view(*password));
+  }
+
+  // If the error was anything other than "it does not exist" we should error out here
+  // This normally means the account exists but we were denied access to it
+  if (password.error() != errSecItemNotFound) {
+    uma_result = FindGenericPasswordResult::kErrorOccurred;
+    OSSTATUS_LOG(ERROR, password.error()) << "Keychain lookup for suffixed key failed";
+    return std::string();
+  }
+
+  // If the suffixed account didn't exist, we should check if the legacy non-suffixed account
+  // exists. If it does we can use that key and migrate it to the new account
+  password =
       keychain_->FindGenericPassword(GetServiceName(), GetAccountName());
 
   if (password.has_value()) {
     uma_result = FindGenericPasswordResult::kPasswordFound;
+
+    // If we found the legacy account name we should copy it over to
+    // the new suffixed account
+    OSStatus error = keychain_->AddGenericPassword(
+        GetServiceName(), suffixed_account_name, *password);
+
+    if (error == noErr) {
+      // If we successfully made the suffixed account we can delete the old
+      // account to ensure new apps don't try to use it and run into IAM
+      // issues
+      error = keychain_->ItemDelete(GetServiceName(), GetAccountName());
+      if (error != noErr) {
+        OSSTATUS_DLOG(ERROR, error) << "Keychain delete for legacy key failed";
+      }
+    } else {
+      OSSTATUS_DLOG(ERROR, error) << "Keychain add for suffixed key failed";
+    }
+
     return std::string(base::as_string_view(*password));
   }
 
   if (password.error() == errSecItemNotFound) {
     uma_result = FindGenericPasswordResult::kPasswordNotFound;
     return AddRandomPasswordToKeychain(*keychain_, GetServiceName(),
-                                       GetAccountName());
+                                       suffixed_account_name);
   }
 
   OSSTATUS_LOG(ERROR, password.error()) << "Keychain lookup failed";
diff --git a/crypto/apple/keychain.h b/crypto/apple/keychain.h
index 1d2264a5229206f45d1a9bcb009d47180efa6a8b..4472e5b605e09659bd75cd4797f073775fe4b354 100644
--- a/crypto/apple/keychain.h
+++ b/crypto/apple/keychain.h
@@ -51,6 +51,11 @@ class CRYPTO_EXPORT Keychain {
       std::string_view account_name,
       base::span<const uint8_t> password) const = 0;
 
+#if BUILDFLAG(IS_MAC)
+  virtual OSStatus ItemDelete(std::string_view service_name,
+                              std::string_view account_name) const = 0;
+#endif  // BUILDFLAG(IS_MAC)
+
  protected:
   Keychain();
 };
diff --git a/crypto/apple/keychain_secitem.h b/crypto/apple/keychain_secitem.h
index eb74282adaba24ebd667f0ab3fc34dbe4cd8b527..0d25e49e2fa1b374d6867b8c602f7685a7f9498d 100644
--- a/crypto/apple/keychain_secitem.h
+++ b/crypto/apple/keychain_secitem.h
@@ -23,6 +23,11 @@ class CRYPTO_EXPORT KeychainSecItem : public Keychain {
       std::string_view service_name,
       std::string_view account_name,
       base::span<const uint8_t> password) const override;
+
+#if BUILDFLAG(IS_MAC)
+  OSStatus ItemDelete(std::string_view service_name,
+                      std::string_view account_name) const override;
+#endif  // BUILDFLAG(IS_MAC)
 };
 
 }  // namespace crypto::apple
diff --git a/crypto/apple/keychain_secitem.mm b/crypto/apple/keychain_secitem.mm
index a8d50dd27db52526b0635c2b97f076df1994a6aa..464c17909b9a554b269a70ea08771da6ec7ac011 100644
--- a/crypto/apple/keychain_secitem.mm
+++ b/crypto/apple/keychain_secitem.mm
@@ -165,4 +165,18 @@
   return base::ToVector(base::apple::CFDataToSpan(password_data));
 }
 
+#if BUILDFLAG(IS_MAC)
+OSStatus KeychainSecItem::ItemDelete(std::string_view service_name,
+                                     std::string_view account_name) const {
+  NSDictionary* query = @{
+    CFToNSPtrCast(kSecClass) : CFToNSPtrCast(kSecClassGenericPassword),
+    CFToNSPtrCast(kSecAttrService) : base::SysUTF8ToNSString(service_name),
+    CFToNSPtrCast(kSecAttrAccount) : base::SysUTF8ToNSString(account_name),
+  };
+  base::apple::ScopedCFTypeRef<CFDictionaryRef> cf_query(
+      NSToCFOwnershipCast(query));
+  return SecItemDelete(cf_query.get());
+}
+#endif
+
 }  // namespace crypto::apple
diff --git a/crypto/apple/mock_keychain.cc b/crypto/apple/mock_keychain.cc
index 080806aaf3fc10548b160850ad36ef3519ea2b6f..98625524b668b86c857d5a8910bfb53b3ab40575 100644
--- a/crypto/apple/mock_keychain.cc
+++ b/crypto/apple/mock_keychain.cc
@@ -56,6 +56,11 @@ OSStatus MockKeychain::AddGenericPassword(
   return noErr;
 }
 
+OSStatus MockKeychain::ItemDelete(std::string_view service_name,
+                                  std::string_view account_name) const {
+  return noErr;
+}
+
 std::string MockKeychain::GetEncryptionPassword() const {
   IncrementKeychainAccessHistogram();
   return kPassword;
diff --git a/crypto/apple/mock_keychain.h b/crypto/apple/mock_keychain.h
index 680efe0312c81449e069c19d9c6ef146da7834db..102db6013b505fed32db176a90f5176118f62773 100644
--- a/crypto/apple/mock_keychain.h
+++ b/crypto/apple/mock_keychain.h
@@ -43,6 +43,11 @@ class CRYPTO_EXPORT MockKeychain : public Keychain {
       std::string_view account_name,
       base::span<const uint8_t> password) const override;
 
+#if BUILDFLAG(IS_MAC)
+  OSStatus ItemDelete(std::string_view service_name,
+                      std::string_view account_name) const override;
+#endif  // BUILDFLAG(IS_MAC)
+
   // Returns the password that OSCrypt uses to generate its encryption key.
   std::string GetEncryptionPassword() const;
 
